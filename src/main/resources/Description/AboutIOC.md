`IOC`即反转抗战,把各个组件之间的强耦合变成组件和容器之间的联系，需要什么依赖，就由容器注入，而不是显性的new一个，因此可以避免在组件类显示的new其他组件导致日后维护问题。

简单IOC容器构成：
1. `注解标记`：定义注解，用于给参考的组件和需要注入的注解字段进行标记
2. `类加载反转`：定义类加载器，扫描指定或全部的目录下的class文件，把含有组件标记的类全部加载到一个 ClassName 与组件的K-V键值对中
3. `组件实例化`：遍历加载的标记类，将其全部初始化成一个类，并存入 ClassName-Obj 的 k-v 键值对中
4. `更新对象` ： 扫描特殊的定义或配置文件中的定义，并使用其重新构建对象，，使用该对象替换 k-v 中原有的对象
5. `依赖注入` ：获取打有控制实例的所有字段`field`，遍历判断是否含有注入标记，若有则将其注入
6. `MVC过滤`： 获取标记控制类，及其注解中的值作为MVC路径，并写入到 method 中，设置一个监听其，监听输入的路径匹配后输入即可

相关方法：
+ **类加载反转**，使用`file`读取全部的文件，判断是否是`class`结尾，若是替换为`.`，并去掉前N（和启动类地址\）一样的长度和末尾class,即全类名，同时可以使用`classLoader.loadClass`把其加载为一个Class类，可以递归判断是否还有某个接口对其进行过滤和分类
+ **组件实例化**，直接使用`Class.newInstance()`进行实例化，但要判断是否是接口或者实现类，然后根据其类型 进行实例化
+ **更新对象**，在注入前可以根据 配置文件 或 其他 对对象容器进行更新
+ **依赖注入**，使用`Class.getDeclaredFields();`获取打有注解的类的字段，并判断其是否有注入的注解，若有直接使用`field.set(object, vlaue);`进行注入
